#include <iostream>
#include <vector>
#include <random>
#include <algorithm>
#include <chrono>
#include <cstdio>
#include <cmath>
#include <exception>

class Figure 
{
public:
    Figure() = default;

    virtual double Area() = 0;
    virtual void Print() {};
};

class Parallelogram : public Figure
{
public:
    Parallelogram() = default;
    Parallelogram(double h, double l) :
        height(h),
        width(l)
    {}

    void SetHeight(double h) { height = h; }
    void SetWidth(double l) { width = l; }

    void SetParams(double h, double l)
    {
        height = h;
        width = l;
    }

    virtual double Area()
    {
        return width * height;
    }

    virtual void Print()
    {
        std::cout << "Площадь параллелограмма ("
            << "высота: " << height
            << " основание: " << width
            << ") = "
            << Area()
            << std::endl;
    }

protected:
    double height{ 0 };
    double width{ 0 };
};

class Circle : public Figure
{
public:
    Circle() = default;
    Circle(double rad) : radius(rad) {}

    void SetRadius(double rad)
    {
        radius = rad;
    }

    virtual double Area()
    {
        return radius * radius * Pi;
    }

    virtual void Print()
    {
        std::cout << "Площадь круга ("
            << "радиус: " << radius
            << ") = "
            << Area()
            << std::endl;
    }

private:
    double radius{ 0 };
    const double Pi{ 3.14159265 };
};

class Rectangle: public Parallelogram
{
public:
    Rectangle() = default;
    Rectangle(double x, double y) : Parallelogram(x, y) {}

    virtual void Print()
    {
        std::cout << "Площадь прямоугольника ("
            << "высота: " << height
            << " ширина: " << width
            << ") = "
            << Area()
            << std::endl;
    }
};

class Square : public Parallelogram
{
public:
    Square() = default;
    Square(double x) : Parallelogram(x, x) {}

    virtual void Print()
    {
        std::cout << "Площадь квадрата ("
            << "сторона: " << height
            << ") = "
            << Area()
            << std::endl;
    }
};

class Rhombus : public Parallelogram
{
public:
    Rhombus() = default;
    Rhombus(double s) : Parallelogram(s, s) {}

    virtual void Print()
    {
        std::cout << "Площадь ромба ("
            << "сторона: " << height
            << ") = "
            << Area()
            << std::endl;
    }
};

// Task 2 //

class Car
{
public:
    Car()
    {
        std::cout << "Car::Car()" << std::endl;
    }

    Car(const std::string& comp, const std::string& mod) :
        company(comp),
        model(mod)
    {
        std::cout << "Car::Car(" << company << ", " << model << ")" << std::endl;
    }
protected:
    std::string company{};
    std::string model{};

};

class PassengerCar : virtual public Car
{
public:
    PassengerCar()
    {
        std::cout << "PassangerCar::PassangerCar()" << std::endl;
    }
};

class Bus : virtual public Car
{
public:
    Bus()
    {
        std::cout << "BusCar::BusCar()" << std::endl;
    }
};

class Minivan : public PassengerCar, public Bus
{
public:
    Minivan()
    {
        std::cout << "Minivan::Minivan()" << std::endl;
    }

    Minivan(const std::string& comp, const std::string& mod) : Car(comp, mod)
    {
        std::cout << "Minivan::Minivan(" << company << ", " << model << ")" << std::endl;
    }
};

// Task 3 //

enum ExitCode
{
    NoError,
    DevisionByZero,
    IntegerOverflow
};

class Fraction
{
public:
    Fraction() = default;
    Fraction(const Fraction&) = default;
    Fraction& operator=(const Fraction&) = default;
    Fraction(int64_t num, int64_t denom) { SetValue(num, denom); }

    void SetValue(int64_t num, int64_t denom)
    {
        if (denom == 0)
        {
            std::cerr << "Ошибка! Знаменатель не может равняться нулю. (Файл: " << __FILE__ << ", строка: " << __LINE__ << ")" << std::endl;
            std::cerr << "\t" << num << "/" << denom << std::endl;
            exit(ExitCode::DevisionByZero);
        }
        else if (num == 0) {
            numerator = 0;
            denominator = 1;
        }
        else {
            int sign = 1;

            if (CheckOverflow(num) < 0) {
                sign *= -1;
                num *= -1;
            }
            if (CheckOverflow(denom) < 0) {
                sign *= -1;
                denom *= -1;
            }

            int64_t divisor = GreatestCommonDivisor(num, denom);
            numerator = num / (divisor * sign);
            denominator = denom / divisor;
        }
    }

    int64_t GetNumerator() const { return numerator; }
    int64_t GetDenominator() const { return denominator; }

    Fraction& operator++()
    {
        numerator++;
        denominator++;
        return *this;
    }

    Fraction operator++(int)
    {
        Fraction old = *this;
        numerator++;
        denominator++;
        return old;
    }

    Fraction& operator--()
    {
        numerator--;
        denominator--;
        return *this;
    }

    Fraction operator--(int)
    {
        Fraction old = *this;
        numerator--;
        denominator--;
        return old;
    }

    Fraction& operator+=(const Fraction& other) { return *this = *this + other; }
    Fraction& operator+=(const int64_t& s) { return *this = *this + s; }
    Fraction& operator*=(const Fraction& other) { return *this = *this * other; }
    Fraction& operator*=(const int64_t& s) { return *this = *this * s; }
    Fraction& operator/=(const Fraction& other) { return *this = *this / other; }
    Fraction& operator/=(const int64_t& s) { return *this = *this / s; }
    Fraction& operator-=(const Fraction& other) { return *this = *this - other; }
    Fraction& operator-=(const int64_t& s) { return *this = *this - s; }

    operator float() { return (static_cast<float>(numerator)) / denominator; }
    operator double() { return (static_cast<double>(numerator)) / denominator; }

    friend Fraction operator+(const Fraction& lhs, const Fraction& rhs);
    friend Fraction operator+(const Fraction& f, const int64_t& s);
    friend Fraction operator+(const int64_t& s, const Fraction& f);
    friend Fraction operator-(const Fraction& lhs, const Fraction& rhs);
    friend Fraction operator-(const Fraction& f, const int64_t& s);
    friend Fraction operator-(const int64_t& s, const Fraction& f);
    friend Fraction operator*(const Fraction& lhs, const Fraction& rhs);
    friend Fraction operator*(const Fraction& f, const int64_t& s);
    friend Fraction operator*(const int64_t& s, const Fraction& f);
    friend Fraction operator/(const Fraction& lhs, const Fraction& rhs);
    friend Fraction operator/(const Fraction& f, const int64_t& s);
    friend Fraction operator/(const int64_t& s, const Fraction& f);
    friend bool     operator<(const Fraction& lhs, const Fraction& rhs);
    friend bool     operator>(const Fraction& lhs, const Fraction& rhs);
    friend bool     operator==(const Fraction& lhs, const Fraction& rhs);
    friend bool     operator!=(const Fraction& lhs, const Fraction& rhs);
    friend bool     operator>=(const Fraction& lhs, const Fraction& rhs);
    friend bool     operator<=(const Fraction& lhs, const Fraction& rhs);

    friend std::ostream& operator<<(std::ostream& stream, const Fraction& obj);

    void Print()
    {
        if (denominator == 1)
            std::cout << numerator;
        else
            std::cout << numerator << "/" << denominator;
    }

private:
    int64_t CheckOverflow(int64_t x)
    {
        if ((x > std::numeric_limits<int64_t>::max()) || (x < std::numeric_limits<int64_t>::min())) {
            std::cerr << "Ошибка! Целочисленное переполнение." << std::endl;
            exit(ExitCode::IntegerOverflow);
        }
        else {
            return x;
        }
    }

    int64_t GreatestCommonDivisor(int64_t x, int64_t y)
    {
        if (x == 0) {
            return y;
        }
        return GreatestCommonDivisor(y % x, x);
    }

    Fraction Invert() const
    {
        if (numerator == 0) {
            std::cout << "Не могу инвертировать ноль." << std::endl;
            return Fraction(numerator, denominator);
        }
        else {
            return Fraction(denominator, numerator);
        }
    }

private:
    int64_t numerator{ 1 };
    int64_t denominator{ 1 };
};

inline Fraction operator+(const Fraction& lhs, const Fraction& rhs)
{
    Fraction frac;

    frac.numerator = lhs.numerator * rhs.denominator + rhs.numerator * lhs.numerator;
    frac.denominator = lhs.denominator * rhs.denominator;

    return frac;
}

inline Fraction operator+(const Fraction& f, const int64_t& s)
{
    Fraction temp(s, 1);
    return f + temp;
}

inline Fraction operator+(const int64_t& s, const Fraction& f)
{
    return f + s;
}

inline Fraction operator-(const Fraction& lhs, const Fraction& rhs)
{
    Fraction frac;

    frac.numerator = lhs.numerator * rhs.denominator - rhs.numerator * lhs.numerator;
    frac.denominator = lhs.denominator * rhs.denominator;

    return frac;
}

inline Fraction operator-(const Fraction& f, const int64_t& s)
{
    Fraction temp(s, 1);
    return f - temp;
}

inline Fraction operator-(const int64_t& s, const Fraction& f)
{
    return int64_t(-1) * (f - s);
}

inline Fraction operator*(const Fraction& lhs, const Fraction& rhs)
{
    Fraction frac;

    frac.numerator = lhs.numerator * rhs.numerator;
    frac.denominator = lhs.denominator * rhs.denominator;

    return frac;
}

inline Fraction operator*(const Fraction& f, const int64_t& s)
{
    return Fraction(f.numerator * s, f.denominator);
}

inline Fraction operator*(const int64_t& s, const Fraction& f)
{
    return f * s;
}

inline Fraction operator/(const Fraction& lhs, const Fraction& rhs)
{
    Fraction frac;

    frac.numerator = lhs.numerator * rhs.denominator;
    frac.denominator = lhs.denominator * rhs.numerator;

    return frac;
}

inline Fraction operator/(const Fraction& f, const int64_t& s)
{
    Fraction temp(s, 1);
    return f / temp;
}

inline Fraction operator/(const int64_t& s, const Fraction& f)
{
    Fraction temp = f / s;
    return temp.Invert();
}

inline bool operator<(const Fraction& lhs, const Fraction& rhs)
{
    return ((lhs.numerator * rhs.denominator) - (rhs.numerator * lhs.denominator)) < 0;
}

inline bool operator>(const Fraction& lhs, const Fraction& rhs)
{
    return ((lhs.numerator * rhs.denominator) - (rhs.numerator * lhs.denominator)) > 0;
}

inline bool operator==(const Fraction& lhs, const Fraction& rhs)
{
    return (lhs.numerator == rhs.numerator) && (lhs.denominator == rhs.denominator);
}

inline bool operator!=(const Fraction& lhs, const Fraction& rhs)
{
    return !(lhs == rhs);
}

inline bool operator>=(const Fraction& lhs, const Fraction& rhs)
{
    return (lhs > rhs) || (lhs == rhs);
}

inline bool operator<=(const Fraction& lhs, const Fraction& rhs)
{
    return (lhs < rhs) or (lhs == rhs);
}

inline std::ostream& operator<<(std::ostream& stream, const Fraction& obj)
{
    if (obj.denominator == 1) {
        stream << obj.numerator;
    }
    else {
        stream << obj.numerator << "/" << obj.denominator;
    }
    return stream;
}

// Task 4 //

enum class CardFace : int
{
    Ace,
    Two,
    Three,
    Four,
    Five,
    Six,
    Seven,
    Eight,
    Nine,
    Ten,
    Jack,
    Queen,
    King,
    Max
};

enum class CardSuit : int
{
    Heart,
    Spade,
    Club,
    Diamond,
    Max
};


class Card
{
public:
    Card() = default;
    Card(CardFace f, CardSuit s, bool opened = false) :
        face(f),
        suit(s),
        isOpened(opened)
    {
    }

    int Open() { isOpened = true; return GetNominal(); }
    bool IsOpened() { return isOpened; }
    CardFace GetFace() { return face; }
    void Flip() { isOpened = !isOpened; }

    int GetNominal()
    {
        if (face >= CardFace::Ace && face <= CardFace::Nine)
            return static_cast<int>(face) + 1;
        else if (face >= CardFace::Ten && face <= CardFace::King)
            return 10;

        return 0;
    }

    void Show()
    {
        std::cout << (isOpened ? facesChar[static_cast<size_t>(face)] : "X") << " ";
    }

private:
    bool isOpened{ false };
    CardFace face{ CardFace::Max };
    CardSuit suit{ CardSuit::Max };
    const char* facesChar[static_cast<size_t>(CardFace::Max)]{ "A","2","3","4","5","6","7","8","9","10","J","Q","K" };
};

int main()
{
    setlocale(LC_ALL, "Russian");

    Parallelogram parallelogram(10, 20);
    Circle circle(10);
    Rectangle rectangle(10, 20);
    Square square(10);
    Rhombus rhombus(10);

    auto Print = [](Figure* f) {f->Print(); };

    Print(&parallelogram);
    Print(&circle);
    Print(&rectangle);
    Print(&square);
    Print(&rhombus);

    std::cout << std::endl;

    Minivan minivan;

    Minivan minivan2("Суперфирма", "Суперминивен");
       
    std::cout << std::endl;

    Fraction f1(100, 22);
    Fraction f2(34, 23);

    if (f1 > f2) {
        std::cout << f1 << " больше " << f2 << std::endl;
    }
    else {
        std::cout << f1 << " меньше " << f2 << std::endl;
    }

    std::cout << f1 << " + " << f2 << " = " << f1 + f2 << std::endl;

    std::cout << f1 << " * 5 = " << f1 * int64_t(5) << std::endl;
    f1.Print();
    std::cout << std::endl;

    std::cout << f1 << " / " << f2 << " = " << f1 / f2 << std::endl;

    Fraction f3(100, 22);
    Fraction f4(100, 22);

    if (f3 == f4) {
        std::cout << f3 << " равно " << f4 << std::endl;
    }
    else {
        std::cout << f3 << " не равно " << f4 << std::endl;
    }

    f3++;

    if (f3 == f4) {
        std::cout << f3 << " равно " << f4 << std::endl;
    }
    else {
        std::cout << f3 << " не равно " << f4 << std::endl;
    }

    std::cout << std::endl;

    Card c(CardFace::King, CardSuit::Heart);
    c.Show();
    c.Flip();
    c.Show();
}
